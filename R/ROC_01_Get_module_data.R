#' Get obj for module building:
#' @details
#' check groups # be sure the two set have same groups.
#' check variables: use the intersect vars by default.
#' clean the var names : remove the blank and other codes
#' when the var wasn't started with letters, the head will be added.
#' generate formulas
#'
#' @param sig_v sig variables, character vector.
#' @param train_set ExperimentSet S4 generated by Train data.
#' @param test_set ExperimentSet S4 generated by
#' @return module_data a list with data and formula for moduling.
#'
#' @export
get_module_data <- function(train_set, test_set, sig_v){
  module_data <- list() ## for output
  module_data$train <- get_ls_for_model(set = train_set)
  module_data$test  <- get_ls_for_model(set = test_set)
  module_data$train_note <- train_set@experimentData@title
  module_data$test_note  <-  test_set@experimentData@title

  sig_v <-  sig_v %>% process_var_Name(input_name = .)
  module_data$final_sig_v <- intersect(module_data$train %>% colnames(), module_data$test %>% colnames()) %>% intersect(.,sig_v)
  ### 最后生成formula即可。
  module_data$my_formula  <- module_data$final_sig_v %>%
    paste0(., collapse = "+") %>%
    paste0("group ~  ", .) %>% as.formula()
  return(module_data)
}


#' Turn the ExperimentSet S4 into a data frame
#' @param set train_set or test_set, ExperimentSet. process and get the new dat for module.
#' @return a dataframe with "group" and other var.
#' @export
get_ls_for_model <- function(set){
  set@assayData$exprs
  dat <- set@assayData$exprs %>% t %>% data.frame(., stringsAsFactors = T, check.names = F)
  # group_levels <- set$ClassNote %>% unique %>% sort
  group_v <- rownames(dat) %>% match(., set@phenoData@data$SampleID) %>% set@phenoData@data$ClassNote[.]
  dat[,"group"] <- group_v %>% factor(., labels = 0:1) %>% as.character() %>% as.numeric(.)

  ## factor 的level在未指定时，会自动进行排序。
  dat %>% head
  colnames(dat) <-  dat %>% colnames %>% process_var_Name(input_name = .)
  return(dat)
}

#' process_Name for module.
#' 清洗变量名
#' replace and remove sth to ensure the var name can be used correctly in a formular
#' @param input_name name vector :to be cleaned.
#' @param var_head the head for variable which wasn't started with letters.
#' @examples
#' \dontrun{
#' input_name <- c("L_Aspartic acid", "L_Serine","9987","_ddd dkkj")
#' process_var_Name(input_name = input_name)
#' }
#' @export
process_var_Name <- function(input_name, var_head = "V"){
  head <- paste0(var_head, "\\1")
  input_name %>% gsub("[-*+ ().,;]","_",.) %>% gsub("(^[^a-zA-Z])",head,.)
}
# input_name <- c("L_Aspartic acid", "L_Serine","9987","_ddd dkkj")
# process_var_Name(input_name = input_name)


if(F){
  iris %>% head
  demo_df <- iris$Species %in% c("versicolor", "virginica") %>% iris[.,] ## 仅保留2种水平
  rownames(demo_df) <- paste0("Person",1:nrow(demo_df))
  IS_train <- sample(x = c(T,F),size = nrow(demo_df), replace = T, prob = c(0.7,0.3))
  train_m <- demo_df[IS_train,1:4] %>% t
  test_m <- demo_df[!IS_train,1:4] %>% t
  ### 需要有SampleID和ClassNote这两列。
  group.train_df <- data.frame(SampleID = rownames(demo_df[IS_train,]), ClassNote = demo_df[IS_train,  5])
  group.test_df  <- data.frame(SampleID = rownames(demo_df[!IS_train,]), ClassNote = demo_df[!IS_train,  5])
  rownames(group.train_df) <- group.train_df$SampleID
  rownames(group.test_df) <- group.test_df$SampleID
  ## Get data set
  Train.set <- Biobase::ExpressionSet(assayData = train_m,
                                      phenoData = new("AnnotatedDataFrame", data = group.train_df),
                                      experimentData = new("MIAME", title = "demo_train"))
  Test.set <- Biobase::ExpressionSet(assayData = test_m,
                                     phenoData = new("AnnotatedDataFrame", data = group.test_df),
                                     experimentData = new("MIAME", title = "demo_test"))
  ### Get module data
  module_obj <- get_module_data(
    sig_v = test_m %>% rownames, #c("L_Aspartic acid", "L_Serine","9987","_ddd dkkj"),
    train_set = Train.set,
    test_set = Test.set)
  ## do the prediction by combined functions
  pulled_df <- Combine_modules(module_obj)
  pulled_df
  ## do the prediction by each single functions
  res_by_LR.step <- module.LR.step(module_obj)
  res_by_LR.step
}
